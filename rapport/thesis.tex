%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EPFL report package, main thesis file
% Goal: provide formatting for theses and project reports
% Author: Yann Gabbud <yann.gabbud@epfl.ch>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt,oneside]{report}
% Options: MScThesis, BScThesis, MScProject, BScProject
\usepackage[MScThesis,lablogo]{EPFLreport}
\usepackage{xspace}
\usepackage{nicematrix}
\usepackage{caption}

\title{NFTiX: A Non-Custodial Decentralized Ticket Engine Enabling Secure and Regulated Ticket Exchange Between Untrusted Parties}
\author{Yann Gabbud}
\authorAddress{yann.gabbud@epfl.ch}
\affiliation{Distributed Computing Laboratory \\
and \\
Secutix SA, an ELCA company \\}
\supervisor{Mr. Denis Komarov}
\adviser{Prof. Rachid Guerraoui}
% \coadviser{Second Adviser}
% \expert{The External Reviewer}

\newcommand{\sysname}{FooSystem\xspace}

\begin{document}
\maketitle
% \makededication
\makeacks

\begin{abstract}
Players in the ticketing industry are constantly fighting against the black market and fraud to ensure that none of their customers are harmed by malicious people. In recent years, blockchain-based digital tickets have started to become more popular. The idea is to store tickets on the blockchain to guarantee their origin and integrity. Secutix has some experience in this area through their product TIXnGO. Two questions now arise. How to ensure that ticket resales are secure and regulated and how to build a decentralized ticket marketplace. \\

This thesis seeks to show that it is possible to build the foundations of a decentralized, non-custodial and regulated user management system, ticket management system and marketplace based on smart contracts, oracles and indexers. Our system is composed of four smart contracts. The first manages users and access control. The second manages events and ticket business logic. The third manages ticket exchanges between users. And the last one manages the TIX token, the utility token of NFTiX. In addition to contracts our systems is composed of three oracles that complement the smart contracts. The oracles bring data on-chain and compute the business logic that cannot be done on-chain. \\

We believe that our contribution is necessary because current solutions are mostly not decentralized or do not take full advantage of blockchain technologies. Moreover, having a regulated market is necessary and will certainly become the norm in the coming years when governments begin to regulate blockchain technologies. \\
\end{abstract}

\maketoc

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%
The ticketing industry is a big market which is expected to reach a capitalization of around 60 billion by 2026. Every year, people all over the world buy tickets for football matches, concerts or festivals. Unfortunately, sometimes they pay too much for a ticket or they buy fake tickets sold by dishonest people.

A ticket is usually a simple PDF with a QR code and some information such as the start time of the event or the location of the event. This PDF is generally sent by email to a spectator \footnote{You can find more information about the ticketing terminology in the  \hyperref[sec:ticketing_terminology]{background} section.} who prints it or keeps it on his phone. Once at the event, the spectator shows his ticket which is scanned by the staff. If the ticket is valid the spectator can enter.

This approach is very simple and practical to use for both the spectator and the organizer of the event. However, it is also very insecure. Indeed nothing prevents someone from buying a ticket and then reselling it to several different people. People who purchase the ticket have no way of knowing that there are multiple instances of the same ticket in circulation. Therefore, although the ticket is valid, only the first person who scans this ticket will be able to enter the event. Others will be refused entry because the ticket has already been scanned. Note, that it is even possible for a dishonest person to simply forge fake tickets that look deceptively like an original without buying one first.

One solution that event organizers use is to issue name tickets. As the ticket is nominative, it is impossible to forge a fake one. In addition, no one wants to buy a named ticket that is not in their name because they will be denied entry. While this mitigation works, it complicates a lot ticket resale in secondary markets because each time someone wants to resell a ticket, the organizer must delete the old ticket and issue a new one which is really inconvenient.

Secutix SA, a famous player in the ticketing industry, started to develop in 2018 a new product called TIXnGO which aims to prevent fraud. The goal of TIXnGO is to replace traditional paper tickets with digital tickets recorded on a blockchain in a smart contract. Here is an overview of how it works. A user buys a ticket from an organizer. Instead of receiving the ticket by mail, the user is invited to download the TIXnGO mobile application and to register by giving and verifying his email address. Once the user is registered, the digital ticket is created and injected into the smart contract. The smart contract saves the ticket and its owner. Finally, the user is notified that his ticket is available on the TIXnGO application. Once the day of the event has arrived, the user presents his smartphone to the access control which lets him enter.

This approach works very well to fight against fraud because only an organizer registered on TIXnGO can inject tickets on the blockchain. It is impossible for a malicious user to forge fake tickets and put them into circulation because the only way for him to do so is to register on TIXnGO and thus reveal his identity.

However, their approach is not sufficient because it is only partially decentralized and does not take full advantage of blockchain technology. Indeed, the blockchain is only used to store tickets. This certainly brings security and transparency, but a blockchain can be much more than a simple secure database. Moreover, their approach is custodial which means that users do not actually own their tickets and cannot use their own crypto wallet to store their tickets. Finally, this approach only partially addresses the problem of the black market. Indeed, nothing prevents a dishonest user from amassing numerous tickets and reselling them at high prices. To fight the black market, TIXnGO monitors all ticket movements to detect suspicious behavior. This is easy to do because all operations carried out on the blockchain are logged. Therefore, it is possible to know who is the original purchaser of a ticket, who is the current owner of a ticket and who were the previous owners of a ticket. TIXnGO analyzes this data and triggers alerts when illegal behaviors are detected. If necessary, measures are taken.

Ideally, the ticketing industry needs a user management system, a ticket management system and a marketplace that are fully decentralized, transparent, secure, and GDPR compliant. In addition, the marketplace must make it possible to easily resell tickets while allowing market regulation through transfer and resale rules \footnote{A resale rule is for example the resale price of a ticket cannot exceed more than 20\% of the initial price.} in order to fight the black market.

However, building such a system is not easy. The first challenge comes from the immutability of the logic of smart contracts. Once a smart contract has been deployed on the blockchain, it is no longer possible to modify it. This is a huge constraint because it means that all the logic, including the transfer and resale rules, must be planned in advance and cannot be changed later on. To change the logic, you must deploy a new smart contract with the new logic. You should know that deploying a smart contract can be very expensive. On the Ethereum blockchain, the cost of deploying a smart contract can go up to several thousand CHF in the event of heavy network congestion. Unfortunately, it is not possible to plan everything in advance because the rules often change over time. What was relevant in the past is not necessarily relevant now or in the future. Here is an example. In 2021 the English government imposed on event organizers to restrict the transfer and resale of tickets to only English citizens in order to limit the number of foreigners entering the country and therefore to fight against the spread of Covid19. This kind of event is typically impossible to anticipate. Therefore, to manage this new scenario it is necessary to deploy a new smart contract that supports the new constraints and so to pay again. It's really not practical in a real situation. We therefore need a system that is easily scalable.

The second challenge is the size of a smart contract. A smart contract cannot exceed a certain size limit. If this size is exceeded, it is not possible to deploy it. This therefore limits the complexity of the logic that a smart contract can have. The problem is that organizers have a lot of different logic and rules depending on the type of event or the location of the event. In addition, these rules may vary from one organizer to another. For instance, the organizers of the Wimbledon championships have defined more than a hundred different transfer and resale rules. It is clearly not possible to implement all of them in a smart contract. Note however that it is possible to cheat a bit by having a main smart contract calling secondary smart contract methods. However, although this trick allows for more richness in logic, it does not allow for arbitrary high complexity and the operating cost of such an approach is very high.

The third challenge comes from the fact that the blockchain, and therefore the smart contracts, do not have access to external data. Unfortunately, it is not possible to call a database from a smart contract. One solution would be to store all data directly on the blockchain. However, it would be extremely expensive. Moreover, according to the GDPR law, it is forbidden to store data concerning a user on the blockchain and the organizers themselves do not want some of their data to be public. Therefore, much of the logic simply cannot be implemented on a smart contract due to the lack of available data and the law.

Finally, there are three other challenges that should also be mentioned. First, the system must be able to support a very large number of simultaneous operations. In one year, the system can manage up to several million tickets. This represents several thousand operations per day to be processed. Second, operation confirmation time must be relatively short. For example, when a ticket is scanned, the system must take it into account immediately so that it is not possible to enter the event twice with the same ticket. Finally, it must be possible to make complex and heavy queries about the state of the system. For example get all scanned tickets and sort them. Current blockchains are known not to be very good at these exercises at the moment. However, great progress has been made, in particular thanks to layer 2 such as zk rollups, which bring scalability without compromising security.

Since it is not possible to implement and by extension execute arbitrary complex logic on the blockchain, we suggest executing the logic outside the blockchain and verifying by means of a proof on the blockchain that the component responsible for this has done its due diligence. To do this, we propose the following approach. The data necessary for the execution of the logic are stored on a database. The transfer and resale rules are also stored on a database. For each transaction, an oracle checks that the rules are respected. If this is the case, the oracle issues a proof that the transaction is authorized and therefore can be executed on the blockchain. When the user creates the transaction, he attaches the proof issued by the oracle. This proof is verified during the execution of the transaction. If the proof is not valid or has not been issued by the oracle, the transaction is refused. Otherwise, the transaction is executed.

With this approach, we can have smart contracts much simpler, supporting any rules of transfer or resale and less greedy in term of gas. Indeed, the smart contract only verifies that the proof is correct and does not need to execute a complex logic in order to approve or refuse the transaction.

Here is an example illustrating how our approach works. Suppose a spectator wants to resell a ticket. He bought it for 100 CHF and wants to resell it for 115 CHF. Suppose also, that the organizer of the event imposes that the resale price is not higher than 20\% of the initial price. As the resale price is less than 120 CHF, the resale is authorized. Here is the procedure. First, the spectator sends his request to the oracle which checks that the rules are respected. The request contains all the information that will be used to create the resale transaction on the blockchain, such as the identity of the buyer and the resale price. The Oracle uses the information contained in the request to create a transaction approval message, signs it and returns it to the user. The user creates the transaction with the information he has previously provided to the oracle and the approval message signed by the oracle. It sends the transaction to the blockchain which verifies it. The verification is ensured by a smart contract which knows the public key of the oracle. Finally, the transaction is executed.

Implementation and testing show that it is possible to build such a system and that it could be deployed in production. First, this approach is scalable. Indeed, an oracle running on a simple laptop easily supports 1,500 requests per second. The main bottleneck is still the blockchain. Second, verification on the blockchain of the oracle's message leads to a relatively small increase in transaction costs, about 10\%. Note that if we were to run all the logic on the blockchain, the cost increase would be much higher. A simulation of the system on Polygon shows that the cost of performing a resale transaction is less than 1 cent, which is perfectly bearable for the ticketing industry or the users.

Therefore, this approach makes it possible to build a regulated market place that supports any regulation rules. In addition, as the execution is carried out or verified on the blockchain, we ensure a very high level of security and decentralization. The only downside comes from the oracle which is unfortunately not decentralized. However, decentralized oracles, such as Chainlink, exist and can be used to achieve a fully decentralized system.

In summary, our main contribution is to lay the foundations for building a secure, regulated, non-custodial and decentralized user management system, ticket management system and marketplace. We also offer other mechanisms that can be interesting for the ticketing industry such as time-based blockchain logic like automatically close an event once it is over or prevent ticket resale once an event has started. Finally, we want to clarify that although this approach uses the ticketing industry as a scenario, it can be perfectly applied to other sectors with similar needs.

%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%
In this section, we introduce the background needed to understand this thesis. We first present the ticketing industry and the vocabulary it uses. Then we introduce the technologies and dependencies you need to know to understand the design and implementation.

\section{Ticketing terminology}
\label{sec:ticketing_terminology}

\begin{description} 
    \item \textbf{Digital Ticket}: A digital ticket is nothing more than a digital representation of a paper ticket. However, it has many advantages. First, it is more transportable and above all much more easily transferable or resalable than its paper counterpart. It is also more difficult to create fake digital tickets because they are generally cryptographically signed and governed by a system with an access control preventing anyone from putting them into circulation without first being approved. In our case, we use the ERC721 standard to represent digital tickets. This standard works well for digital tickets because it allows us to create unique transferable assets and keep track of who owns them.
    \item \textbf{Ticket wallet}: A ticket wallet is an application that stores digital tickets and displays them when requested by the user. In general, a wallet is a mobile application like the Apple wallet or a wallet dedicated to tickets like the TIXnGO wallet.
    \item \textbf{Event}: An event is a generic term that encompasses sporting events, festivals, concerts, or any other event that you need a ticket to attend.
    \item \textbf{Organizer}: An event organizer, or organizer for short, is a person or entity that creates, manages, and promotes events and sells tickets for them.
    \item \textbf{Spectator}: A spectator is someone who purchases tickets and attends events. A spectator may also transfer or resell tickets he has purchased from an organizer.
    \item \textbf{User}: Sometimes this term is used to encompasses both organizers and spectators who are registered in the system.
    \item \textbf{Ticket Transfer}: A spectator who owns a ticket can transfer it to someone else. This person becomes the new owner of the ticket. This change of ownership is called a ticket transfer.
    \item \textbf{Ticket Resale}: A spectator who owns a ticket can resell it to someone else. This is similar to a ticket transfer except that in addition to the ownership transfer there is also a money transfer. We say the current owner of the ticket is the seller and the person buying the ticket is the buyer. Therefore the seller transfers the ticket and the buyer transfers the money.
    \item \textbf{Ticket Swap}: A spectator who owns a ticket can swap it against another one. This is similar to a ticket resale except that in that case two tickets are exchanged instead of a ticket against money. We call the two parties of a swap A and B, or Alice and Bob.
    \item \textbf{Transfer, resale and swap rules}: Tickets are subject to transfer and resale rules defined by the organizer. These rules define a policy which mainly aims to fight against the black market and fraud. An example of a transfer rule might be that it is prohibited to transfer a ticket to a fan banned for hooliganism. An example of a resale rule might be that the resale price of a ticket cannot exceed more than 20\% of the original price.
    \item \textbf{Ticketing system}: A ticketing system, like Secutix, is a ticket management tool. An event organizer uses a ticketing system to create and manage events, to create, manage and sell tickets for an event, and to provide support and assistance to spectators who purchase tickets for its events.
    \item \textbf{Ticket Distribution System}: A ticket distribution system, such as TIXnGO, is a tool for managing the distribution of digital tickets. A ticket distribution system does not replace a ticketing system but is complementary. Often it also helps to fight against fraud and black market. In general, there are three main components. The first component is a management interface used by the organizer to distribute tickets purchased by spectators and to track who the current owners are. The second component is a ticket wallet which is used by the spectator to store, display, transfer and resell tickets. The third component is a ticket engine which execute the requests of the organizers and the spectators. It is important to note that only a registered organizer can use the management interface. Therefore, only a genuine organizer can distribute tickets such that no fake tickets are in circulation.
    \item \textbf{Marketplace}: A marketplace is a platform that allows the secure sale of assets between parties that do not trust each other. In our case, the assets are tickets. The marketplace displays tickets that are on resale with their resale price. A seller can put a ticket up for resale and withdraw it later if he changes his mind. A buyer can purchase a ticket on resale.
\end{description}

\section{Ethereum blockchain}
Ethereum is an open source blockchain \footnote{https://en.wikipedia.org/wiki/Blockchain} that runs smart contracts. It aims to be a global internet computer for building decentralized applications \footnote{https://en.wikipedia.org/wiki/Decentralized\_application}. It is currently the main blockchain used for DeFi \footnote{https://en.wikipedia.org/wiki/Decentralized\_finance}, NFTs and Dapps.

The system we design is based on the Ethereum blockchain. However, note that our implementation can be deployed on any EVM-compatible blockchain, such as Avalanche, Polygon or Binance smart chain. Note also that it is perfectly possible to implement the design so that the system can be deployed on blockchains that are not EVM-compatible but that support smart contracts such as Solana or Cardano.

\section{Ethereum wallet}
An Ethereum wallet is an application that let a user interact with the blockchain. With his wallet, the user can manage his account and assets. For instance he can get his ETH balance. He can make a transaction to transfer ETH to someone else. He can also connect and access to decentralized applications. A wallet stores a public and a private key. The public key is used to identify the account and by extension its owner. The private key is used to sign transactions and ensure that only the owner of the wallet can interact with his account. More information here \footnote{https://ethereum.org/en/wallets/}.

\section{Custodial vs non-custodial}
As explained in the previous section, the wallet contains a private key to sign transactions. The difference between a custodial approach and a non-custodial approach is minimal but of great importance. In a custodial approach, the platform holds your private key, while in a non-custodial approach, you hold your private key. What must be understood is that when you own your private key, you own your funds!

\section{Transaction}
A transaction is an operation initiated by an external account \footnote{https://ethereum.org/en/developers/docs/accounts/} that changes the state of the blockchain. An example of transaction is a transfer of ETH from one person to another. Since the transaction changes the state of the blockchain, the account that initiates the transaction must pay a transaction fee to the blockchain. In the example, we see that the state of the blockchain is changed because the sender's balance is decreased and the receiver's balance is increased by the transferred amount. More information about transactions here \footnote{https://ethereum.org/en/developers/docs/transactions/}.

\section{Call}
A call is an operation on the blockchain that does not change the state of the blockchain. Both external and contract accounts can make calls. For example, one can make a call to get his ETH balance. Since a call is read-only, the call initiator does not have to pay any fees. More information about calls here \footnote{https://ethereum.stackexchange.com/a/770}

\section{Smart contract}
A smart contract, or contract for short, is a program that runs on the blockchain. As the blockchain is Turing complete, a smart contract can implement any arbitrary logic. However, there are two limitations to keep in mind. The first one is that a smart contract cannot call an external service and only has access to data that is stored on the blockchain or sent with a transaction. The second one is that a smart contract cannot implement arbitrary complex functions. Indeed if a function exceeds a certain complexity, the function will be reverted by the EVM \footnote{https://ethereum.org/en/developers/docs/evm/} because it exceeds the gas limit \footnote{https://ethereum.org/en/developers/docs/gas/#what-is-gas -limit }.

\section{ERC20}
ERC20 \footnote{https://ethereum.org/en/developers/docs/standards/tokens/erc-20/} is the Ethereum standard for creating fungible tokens. It defines a set of rules that must be implemented by any token wishing to be compatible with the standard. The main feature of such a token is fungibility. This means that the tokens are indistinguishable from each other. For example fiat currencies, such as CHF, EUR or USD. are fungible. Any CHF 100 note can be exchanged for another CHF 100 note. Stock auctions are also fungible. Thus, this standard aims to make it possible to represent any fungible asset on the Ethereum blockchain. 

\section{ERC721}
ERC721 \footnote{https://ethereum.org/en/developers/docs/standards/tokens/erc-721/} is a standard for non-fungible tokens. Like the ERC20 standard, ERC721 is a very popular standard. However, it has a different purpose. It aims to represent any non-fungible asset on the Ethereum blockchain. A non-fungible asset can be, for example, an event ticket. Indeed, each ticket has a unique identifier (UID) that distinguishes it from any other ticket for the same event. The Venus of Milo is another example of a non-fungible asset. There is only one Venus that was sculpted by Paros.

\section{Smart contract event}
An event is an information that can be emitted and logged by the blockchain when a transaction is mined. For example, when someone transfers ERC20 tokens, a \textit{Transfer} event is emitted. This event includes the following information: the sender's address, the receiver's address and the amount sent. Events emitted by a smart contract can be used to build indexes to perform complex data queries.

\section{Keccak256}
Keccack256 is one of the most widely used hash functions in the Ethereum ecosystem. This hash function is used in the EVM and in Ethash, the PoW algorithm of Ethereum. Note that this hash function is named keccak256 and not SHA3 \footnote{https://en.wikipedia.org/wiki/SHA-3} even though they are nearly identical. The reason is that keccak256 is an old version of SHA3. SHA3 was slightly modified in August 2015, right after the launch of Ethereum in July 2015. In our system, the oracles use keccak256 to calculate the approval message from user inputs.

\section{ECDSA}
ECDSA, Elliptic Curve Digital Signature Algorithm, is an algorithm used to digitally sign messages. This algorithm is very suitable for blockchains because, compared to its counterparts such as RSA, it uses shorter keys, it has faster signing and encryption operations and it offers the same level of security. Oracles use ECDSA to sign the messages they computed with keccak256.

\section{Blockchain oracle}
As mentioned earlier, smart contracts do not have access to data stored outside of the blockchain. Therefore, blockchain needs a way to bring data securely onto the chain. This is the role of an oracle. It guarantees the authenticity and integrity of this data so that the blockchain can access off-chain data securely without compromising its security.

\section{Graph protocol}
The Graph \footnote{https://thegraph.com/docs/en/about/introduction/} is a protocol used to index blockchain and smart contracts. It is very useful because it allows to build and maintain off-chain indexes tracking the state of the blockchain or smart contracts. Building an off-chain index is very useful because it simplifies access to information and reduces the complexity of smart contracts. There is no need to create and maintain complex data structures in the smart contract in order to be able to query arbitrary data, such as getting all balances of an ERC20 contract above a certain amount. It also allows to query data in bulk, which is not possible with a blockchain call due to the gas limit. Note that indexes are stored in a traditional database such as Postgres.

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related Work}
%%%%%%%%%%%%%%%%%%%%%%
Many projects seek to create blockchain-based digital tickets and marketplace such as B.A.M, Blocktix. EventCHI, FanDragon, PassageX, TicketHash, TIXnGO or GET protocol. For most of them, it's not easy to find out how they work because they don't have documentation open to the public and the product description is aimed primarily at the marketing guys. What we can say is that they all offer a simple form of regulation such as limiting the maximum resale price in order to fight against the black market. They all have a custodial model, i.e. they handle tickets for users. They do not appear to be decentralized and primarily use blockchain as ticket storage.

We detail two systems similar to ours which seem to be the most promising and whose documentation is available: TIXnGO and GET Protocol. We begin by giving an overview of these systems. Then we explain what are the key differences about our approach and how we overcome some of their weaknesses.

Let's start by giving an overview of the two systems. They are both ticket distribution systems. TIXnGO is developed by Secutix SA and GET Protocol is developed by GUTS ticketing. Their approach is to use the blockchain to securely and transparently store tickets and their owners. Now let's take a look at how they work. To do this, we take the example of Fifa which organized the Arab Cup last year and detail the flow from the purchase of tickets until the spectators enter the stadium. First, Fifa sells tickets to spectators through its website. Once the tickets are sold, it sends the distribution system a list of tickets with their owner and ticket details. The distribution system saves everything in a database and stores ticket ID and spectator ID pairs on the blockchain in a smart contract. Once done, it informs the spectators that their tickets are available on the mobile app. From then on, spectators can transfer their tickets to other spectators registered on the system. This feature is very useful because usually someone buys tickets and then gives them to his friends or family. On match day, spectators gain access to the stadium by scanning their ticket at the entrance.

Let's now take a closer look at TIXnGO. The approach fulfills its role well and the partners are very happy with the product. However, there are many things that we believe can be improved. The first point concerns the blockchain. TIXnGO uses its own private blockchain hosted on Amazon servers. Having a private blockchain is very convenient because there are no transaction fees to pay and it is possible to easily correct errors of manipulation as well as a bug in smart contracts. However, a private blockchain doesn't make much sense because no one except TIXnGO has access to it. Organizers and spectators use an API but never communicate directly with the blockchain. Therefore most of the interesting properties of the blockchain such as transparency or direct management of assets by users are lost. To overcome this problem, our approach is based on a public blockchain.

The second point concerns business logic and general design. All the business logic of TIXnGO is managed off-chain by the backend, except the ownership of the ticket which is managed by the blockchain. This approach is very practical because it is much easier to have a business logic off-chain than on-chain. Indeed, there are many constraints such as smart contracts which cannot have an arbitrarily large complexity. In our opinion, it would be better to let the blockchain take care of the business logic because it would allow to really take advantage of the blockchain and not just use it as a database which is certainly very secure but which is also very expensive to operate. This would also make it possible to have a much more decentralized system and avoid a single point of failure. Our approach aims at executing as much of the business logic as possible on-chain. The business logic that cannot be executed on-chain is executed off-chain and then verified on-chain. To do this we use oracles, smart contracts and indexers.

The third point concerns standards. TIXnGO uses homemade smart contracts that could be replaced by standards. There are several very useful standards, which have been extensively tested and are used by many projects. For example, it would be interesting to use the ERC721 standard to represent tickets and to keep track of their owner. The problem for TIXnGO is that it requires many system adjustments because at the moment it does not use Ethereum addresses as identifiers for users but database IDs. Our approach tends to use as much as possible the current standards in order to benefit from the work carried out by the blockchain community and to maximize the interoperability of our system with other projects.

The fourth point, which we think is the most important, concerns custody. TIXnGO uses a custodial approach. In general, this approach is preferred by companies because it is simpler to implement and economically advantageous, especially for an exchange. For TIXnGO, this allows it to control the entire process and therefore to be able to easily intervene in the event of a problem. However, as we mentioned previously, this type of approach implies that the user is not really the owner of his assets because he delegates their management to TIXnGO. You should know that the original purpose of a blockchain is precisely to avoid this by giving control back to the user. Therefore, our approach is non-custodial. Although this approach is more restrictive and more difficult to build, we show that it is possible to design a system that achieves the same objectives as a custodial system and that also gives control back to users! To achieve this objective, we design an on-chain user management system and a role-based access control.

Finally, although TIXnGO allows the resale of tickets, it does not have yet a marketplace. We propose to build a fully decentralized marketplace allowing secure and regulated resales of tickets.

Now let's take a closer look at the GET protocol and compare it to TIXnGO. Note that the systems being very similar, we will not go into details so as not to repeat what has been said above. About the first point, unlike TIXnGO it is deployed on Polygon, a public blockchain. This is a very good thing because it gives visibility on the system to the users. About the second point, we believe it makes better use of the blockchain. In addition to tickets, it stores events on the blockchain. This is a very good idea because it makes it easy to build an index and therefore to filter tickets efficiently by event. However, we believe that like TIXnGO, the system does not take full advantage of what the blockchain has to offer. About the third point, it should be noted that it uses the ERC721 standard to represent tickets on the blockchain. Due to the popularity of this standard, this is a very good design choice as it allows the system to easily interoperate with other systems. On the fourth point, it also uses a custodial approach. All interactions with the system are done through an API. Finally, like TIXnGO, it does not yet have a decentralized marketplace.

To conclude, we must briefly mention Taurus, a fast-growing Geneva startup. Taurus offers financial market infrastructure services and products such as a custody solution used by Swiss bank. This solution allows banks to offer their customers the possibility of buying crypto assets. On top of that, they are building a regulated market, named TDX, to enable the trading and exchange of tokenized securities which is an essential and missing piece in the financial ecosystem and the first in the world as far as I know. The marketplace complies with Swiss securities law and Distributed Ledger Technology (DLT) law.

Although the business is different, it is interesting to see that a Swiss actor seeks to regulate decentralized assets as we seek to do. Unfortunately, there is no documentation and the API is not yet available. Therefore, it is difficult to understand how it works under the hood, except that it is custodial.

%%%%%%%%%%%%%%%%
\chapter{System overview}
%%%%%%%%%%%%%%%%
In this chapter, we first enumerate the goals that the system must achieved. Then, we describe the system's components and the design choices that were made. Several iterations were made before coming up with the final version. Therefore we describe for each component the initial design and then the improvements that were made, if any.

\section{System goals}

NFTiX is a ticket engine that seeks to facilitate ticket exchange between untrusted parties and to provide the following advantages in terms of decentralization, scalability and security.

\begin{description}
  \item \textbf{Non-custodial}: The users own and control their assets. NFTiX provides the service but cannot manipulate user assets.
  \item \textbf{Decentralized}: There is no single point of failure in NFTiX such as a trusted third party.
  \item \textbf{Regulated}: NFTiX has a mechanism that allows to control the resale process so that the black market is limited.
  \item \textbf{High Throughput}: NFTiX supports thousands of daily operations such as tickets issuance, transfers, or resales.
  \item \textbf{Low Latency}: NFTiX offers low latency transaction confirmation.
  \item \textbf{Low Costs}: The operating cost of NFTiX is low for developers, event organizers and spectators.
  \item \textbf{Integrity, authenticity and unforgeability}: NFTiX ensures a high level of security so that the integrity, authenticity and unforgeability of tickets is guaranteed and no fraud is possible.
\end{description}

\section{Architecture overview}

\begin{figure}[h!] 
  \centering
  \includegraphics[width=\textwidth]{architecture_overview.png}
  \caption{Architecture overview}
  \label{fig:architecture_overview}
\end{figure}

This section aims to provide an overview of the main components and their interoperability. As you can see on the figure \hyperref[fig:architecture_overview]{\ref{fig:architecture_overview}}, the system is split in to parts, on-chain and off-chain. The on-chain part contains four smart contracts working together to enforce the business logic. The Identity contract is responsible for tracking the registered users and enforcing the access control policy. The Ticketing contract is responsible for managing events and tickets. The Exchange contract is responsible for ticket resale and ticket swap. The TIX contract is an ERC20 utility token. This token powers the economics of NFTiX. The fees of the platform and the ticket purchase are paid in TIX.  

The off-chain part contains the oracle which are crucial because they allows us to securely execute the business logic that cannot be execute on-chain. The Identifier is responsible for verifying the identity of the new user and allowing them to register on the Identity contract. The Approver is responsible for verifying that the operations on tickets are approved by the organizers. The price Feed is responsible for bringing on-chain the price of the TIX against the ETH and the USD. 

Finally, the graph node is responsible for indexing the smart contract such that we can easily query data. The marketplace is responsible for listing the resale and swap offers. In the next section we give a more detailed description of each components.

\section{Oracles}
Oracles play a crucial role in the system. There are two types of oracle in our system. The first two, the Identifier and the Approver, execute the business logic that cannot be executed on-chain and issue approval messages that are verified on the blockchain. The third, the Price Feed, takes care of sending data on chain, in this case the price of the TIX against the USD and the ETH.

It should be noted that all the oracles have a pair of private/public keys. These keys are used to sign transactions and messages.

A message issued by an oracle is actually a proof that the oracle has done its due diligence. For example in the case of a resale, the Approver certifies that it has checked that the operation complies with the resale rules. Let's look at how such a proof is created. The creation takes place in three steps. First, the oracle checks that the operation is legal. Then, the oracle hash the arguments supplied by the user. To do this, the hash function Keccak256 is used. Once the hash of the arguments has been computed, the oracle creates a signature with its private key and the hash using ECDSA. This signature is the proof returned to the user.

\subsection{Identifier}
The Identifier makes it possible to verify the identity of the organizers and the spectators who wish to register, to store user information on the database and to issue identification proofs allowing users to register on the Identity contract.

At the moment, the oracle only verifies the Ethereum address that the user provides. To do this, the oracle sends a challenge that the user must sign and return to the oracle. The verification is successful if the oracle manages to verify that the message has been signed by the private key corresponding to the address provided by the user. Note that, as the name suggests, the oracle should also verify the identity of the user in order to comply with KYC rule. This verification mechanism is not implemented because outside of the scope of the project. We therefore assume that the oracle performs an identity verification similar to that carried out during the onboarding of Coinbase, Binance or Swissborg, i.e. the user sends photos of his identity card and his face which are then verified thanks to machine learning.

Once the verification is successful, the oracle saves the information that the user has provided and issues a proof of identification built from the Ethereum address and the group to which the user belongs. The group allow to distinguish spectators from organizers and to build the role-based access control. We will come back to this later.

\subsection{Approver}
The Approver is responsible for verifying that the operations on tickets initiated by spectators comply with the rules imposed by the organizers and for issuing proofs of approval allowing spectators to carry out resale and swap transactions. We explain later how resale and swap transactions work.

For a resale transaction, the proof is built from the address of the ticket owner, the token ID (remember that we use non fungible tokens to represent tickets on the blockchain), the resale price and the address of an optional buyer chosen by the seller. If the optional buyer is not specified, the zero address is used to construct the proof. For a swap transaction, the proof is constructed from the address of the spectator A, the address of the spectator B, the ID of the token A and the ID of the token B.

The approval procedure of a transaction works like this. First, the spectator sends a transaction approval request to the Approver providing it with the data that will be used to construct the transaction. The oracle verifies that the transaction respects the rules and issues a proof of approval. The spectator can now use the proof to construct a transaction with the data that he transmitted to the oracle and with the proof that the oracle returned to him.

\subsection{Price feed}
The Price Feed regularly sends the price of TIX against USD and ETH to the TIX smart contract. As a reminder, smart contracts cannot communicate with the outside world and therefore the TIX smart contract has no way of knowing the price of the TIX if it is not transmitted to it.

This oracle works differently from the other two oracles. It communicates directly with the blockchain and therefore does not need to issue proofs. Indeed, as the transactions that the oracle sends are signed, the smart contract only needs to verify that the initiator of the transaction is the Price Feed in order to ensure that the price update is legitimate. Note that the TIX smart contract stores the address of the Price Feed in order to verify that the transaction comes from it and not from a malicious user.

\section{Ethereum blockchain}
The Ethereum blockchain is the cornerstone of the system. It is the one responsible for operating the smart contacts that implement the business logic.

This component must be robust and battle tested to ensure that the execution environment is safe. We chose Ethereum because it is the most mature blockchain at the moment. It has been tested extensively. It hosts many projects. And it has a complete development and test environment.

However, it has a big disadvantage, the high cost of transaction fees induced by the congestion of its network. Unfortunately, it suffers from its popularity. However, many scalability solutions are under development and things should improve. In the meantime, it is possible to deploy the system on Polygon which is EMV-compatible and which offers a good level of security.

\section{Smart contracts}
This section describes the core of NFTiX which is responsible for enforcing the business logic. The core is made up of four smart contracts, the Identity contract, the TIX contract, the Ticketing contract and the Exchange contract. For each contract, we describe first the initial design, then the improvements that have been made in order to correct the initial design errors. You will find several flow diagrams. The flows highlighted in red are off-chain operations, in blue are transactions sent to the blockchain, and in green are on-chain operations.

\subsection{Identity smart contract}
The Identity contract take care of several things. It allows the organizers and spectators to register and unregister from NFTiX. It allows NFTiX to revoke an organizer or a spectator who behaves inappropriately. It stores the addresses of registered organizers and spectators. It stores the Identifier oracle's public key so that it can verify the identification proofs issued by the oracle when an organizer or spectator registers. You can find the flow diagram of the registration in the figure  \hyperref[fig:user_registration]{\ref{fig:user_registration}}.

\begin{figure}[h!]
  \includegraphics[width=\textwidth]{user_registration.png}
  \caption{User registration}
  \label{fig:user_registration}
\end{figure}

This contract also defines and applies the role-based access control policy. For now, the policy is very simple but it can be extended as needed. There are four group: ORGANIZER, SPECTATOR, UNREGISTERED and REVOKED. An organizer who registers gets the ORGANIZER role and a spectator who registers gets the SPECTATOR role. When an organizer or spectator unregisters, their address is marked as UNREGISTERED. If NFTiX bans a user from the system for inappropriate behavior, his address is marked as REVOKED.

\subsection{TIX smart contract}
This contract manages the utility token of NFTiX, the TIX. This contract is ERC20 compliant. The TIX is used to pay platform usage fees and to purchase tickets on resale. It should be noted that the platform generates revenue through the activity of its users. For example, when an organizer creates an event, he must pay a registration fee. When he mints a token, he must pay a minting fee. When a spectator purchases a ticket on resale, a percentage of the resale price is taken and shared between the event organizer and NFTiX.

The contract stores the price of TIX against dollars and ETH. These prices are regularly updated by the price feed oracle. The smart contract also stores the public key of the oracle so that only it can update the prices.

Users can request the current price of TIX against dollars or ETH. They can ask how many TIX an amount in USD or ETH is worth. They can buy TIX with ETH or sell TIX and receive ETH in return. When buying, TIX are minted and when selling, TIX are burned. They can transfer TIX to someone else. Finally, the admin of NFTiX can request the ETH balance of the contract and remove or add ETH in the smart contract.

It is important to note that the token has no real use in itself because we could use ETH instead of TIX. However, it does show to Secutix SA how a utility token can be integrated into the system and used by users. You will find more information on the potential use of the token in the future work section.

Finally, it is to be noted that we made a small improvement to the ERC20 standard which we believe is really helpful in reducing the number of transactions needed when a transfer of tokens is part of a bigger transaction. It also fixes the problem of an attack leveraging a race condition between multiple approval and transfer due to transaction ordering \footnote{https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit}. This improvement consists of creating an off-chain proof allowing a smart contract to transfer tokens on behalf of a user without having to perform an approval transaction first. We call this an externally approved transfer. This type of approval is really helpful in building the exchange. We will come back to its use later.

The proof is constructed in the same way as the proofs used by oracles. The user creates a TIX transfer approval proof with the address of the approved contract, his address, the address of the recipient and the amount to be transferred. The proof is then put as an argument in a transaction and is verified by the TIX contract. Note that this type of approval should be used with caution. We give an analysis of what could go wrong if this mechanism is misused in the security chapter.

\subsection{Ticketing smart contract}
This contract manages events and tickets. As the tickets are represented by NFTs, the contract complies with the ERC721 standard.

Let's start by detailing the events. Events are represented by a data structure containing the following fields: an event ID, the address of the organizer, the name of the event, the place, the opening date and time, the closing date and time and finally the state of the event. 

Three of these fields serve useful purposes for business logic: the event ID, the opening date and time, and the state. The others could be stored off-chain to reduce gas consumption. The event ID is used to distinguish events from each other. This identifier is unique. The opening date and time corresponds to the opening of the doors of the event. This information is used to prevent transfers and resales of tickets after the opening of the event. This measure is necessary to prevent a malicious person from trying to resell a ticket that has already been scanned.

There are three possible states for an event. The first state is PENDING. This state means that the event has been created but that it is not yet open. Therefore, an organizer can create tickets for this event. However, it is impossible to transfer or resell them yet. The second state is OPEN. This state means that the event is activated. Therefore, spectators can transfer and resell their tickets. The last state is CANCELED. This state is obtained when an event is cancelled. With this state, transfers and resales are frozen, as with the PENDING state. Although these two states have the same effects, it is useful to be able to distinguish them in order to filter events and tickets.

Now let's take a look at tickets. A ticket is made up of four fields: a token ID, an event ID, a ticket ID and a state. The token ID is the unique identifier that distinguishes NFTs from each other. The event ID is the event the ticket belongs to. The ticket ID is a unique identifier that allows the organizer to distinguish his tickets. Note that two organizers can share the same ticket ID. Therefore, to uniquely identify a ticket, you must either know its token ID or its ticket ID and its event ID. Finally, like an event, a ticket has a state. The first state is VALID. This means that the ticket can be transferred, resold, swap or used to enter the event. The second state is INVALID. This means that the ticket has been invalidated by the organizer. There can be several reasons for this. It's a cancelled test ticket. Its bearer tried to defraud and its ticket was cancelled. Or the ticket was cancelled for another reason. The last state is SCANNED. This means that the ticket is valid and that the bearer has entered the event. This state is useful because sometimes it is necessary to scan a ticket again in the event, for example, to access the VIP area.

Now let's look at how organizers and spectators can interact with the smart contract. First, it should be noted that some smart contract methods, such as event creation, can only be performed by an organizer. If a spectator attempts to execute one of these methods, the transaction will be reverted. To apply this restriction, the smart contract queries the Identity smart contract to find out if the initiator of the transaction is an organizer. Secondly, it should be noted that an organizer can perform an operation, for example minting a ticket, only if it is related to one of his events. If an organizer tries to interact with assets that they don't own, the transaction is reverted.

An organizer can register a new event. To do this, he must provide all the fields listed above and pay the registration fee. This fee is paid in TIX. It is automatically taken from the organizer's balance. Therefore, the organizer must first have sufficient TIX and approve \footnote{https://tokenallowance.io/} the smart contract to transfer the registration fee amount on its behalf. If either of these two conditions are not satisfied, the transaction is reverted. Note that if the opening date and time is after the closing date and time, the transaction also fails. Once an event is registered, its organizer can update its fields if an error was made during registration. You can find the flow diagram of the event registration in the figure  \hyperref[fig:event_registration]{\ref{fig:event_registration}}.

\begin{figure}[h!]
  \includegraphics[width=\textwidth]{event_registration.png}
  \caption{Event registration}
  \label{fig:event_registration}
\end{figure}

An organizer can mint tickets for his events. To do this, it must provide an event ID that exists, a ticket ID, and an address of a registered spectator who will own the ticket. If the event ID is unknown or if the address does not match a registered spectator, the operation is reverted. The organizer must also pay a minting fee for each minted ticket. The payment of the minting fee is analogous to the payment of the registration fee. The smart contract supports batch injections to make life easier for the organizer. To do this, the organizer must provide an event ID, a ticket ID list and an address list. You can find the flow diagram of the minting in the figure  \hyperref[fig:minting]{\ref{fig:minting}}.

\begin{figure}[h!]
  \includegraphics[width=\textwidth]{minting.png}
  \caption{Minting}
  \label{fig:minting}
\end{figure}

An organizer can burn or update the status of their tickets. This operation is analogous to minting and can also be executed by batch. However, it does not include any fees.

A spectator can transfer a ticket to another spectator. For a transfer to be executed successfully, the transaction initiator must be the ticket owner, the ticket recipient must be a registered spectator, the event must not have started yet, the event state must be OPEN, and the ticket state must be VALID. You can find the flow diagram of the transfer in the figure \hyperref[fig:transfer]{\ref{fig:transfer}}.

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.60]{transfer.png}
  \caption{Transfer}
  \label{fig:transfer}
\end{figure}

Finally, anyone can get all the information related to an event or a ticket by providing the specific event ID or token ID.

This is the initial design. It works but it can be improved. To pay the event registration and the minting fee, the organizer need to approve the Ticketing contract to transfer some of his TIX to NFTiX. It means that the organizer must first do an approval transaction in the TIX contract and then an event registration transaction in the Ticketing contract. Doing two transactions is not ideal because the organizer has to pay two times the base gas fee. However, with the improvement we explain in the previous section, the organizer can create an TIX transfer approval proof to authorize the Ticketing contract to make the transfer on its behalf. With this approach, the organizer only need to do a single transaction and the event registration is now atomic. We do the same for the payment of the minting fee.

As you can see this externally approved transfer are very useful because it allows us to reduce the number of transactions to do. Therefore, we extend the ERC721 standard with this same mechanism. Having this mechanism in the TIX contract and the Ticketing contract enable us to make atomic resale and swap. We details this in the next section.

We would also like to mention an improvement that was ultimately not kept. With the current design, a single smart contract manages all events and tickets for all organizers. It could be useful to have a dedicated ticketing contract per organizer so as not to mix data from different organizers and to be able to have a specific on-chain logic per organizer. To do this, we can use a factory contract similar to the one used by UniswapV3. When an organizer registers an event on the factory, it automatically deploys a Ticketing smart contract dedicated to this event. If we want specific business logic, we can manually deploy a Ticketing contract and then register it to the factory contract. We are not keeping this improvement as we aim to have a generic and simple on-chain logic. For specific business logics, we prefer to use oracles.

\subsection{Exchange smart contract}
The Exchange smart contract allows the spectators to resell and swap their tickets in complete safety. The contract lists all resale and swap offers. In addition, the contract verifies that each transaction has been approved by the Approver before executing it.

Let's start with ticket resale. The resale takes place in two stages. In the first stage the seller creates a resale offer and in the second stage a buyer accepts the offer.

To create the resale offer, the seller must first approve the Exchange contract to operate its ticket. Then, he must specify which token he want to resell and at what price in USD. If he wishes, he can also specify an optional buyer. By specifying an optional buyer, only this person can accept the resale offer. If someone else tries to accept the offer, the transaction is reverted. The seller must also attach the resale approval proof issued by the Approver. The transaction succeeds if the following conditions are met. There is no existing offer to resell this token. There is no existing swap offer for this token. The initiator of the transaction is the owner of the token. The price is not negative. The optional buyer, if defined, is a registered spectator. The approval message is valid and has been signed by the Approver. Note that it is possible to cancel a resale offer as long as it has not yet been accepted.

To accept the resale offer, the buyer must specify which token he wishes to purchase and approve the contract to transfer an amount in TIX equivalent to the resale price. Note that the sale price is specified in USD but the transaction is made in TIX. To find out how many TIXs need to be approved, the buyer requests the current resale price from the contract by providing the token ID of the ticket he wish to purchase. The transaction succeeds if the following conditions are met. A resale offer for the token exists. The buyer is a registered spectator. The buyer is the optional buyer, if specified. The approved amount is sufficient to satisfy the resale.

Note that a fee is taken on each resale. This fee is a percentage of the resale amount. The purpose of this fee is to cover the operating costs of NFTiX and to give a commission to the organizer of the event. The resale amount is split into three shares: the seller share, the NFTiX share and the organizer share which are respectively 98\%, 1\% and 1\% of the resale amount. The seller and the buyer pay each 50\% of this fee. You can find the flow diagram of the resaleV1 in the figure \hyperref[fig:resaleV1]{\ref{fig:resaleV1}}.

\begin{figure}[h!]
  \includegraphics[width=\textwidth]{resaleV1.png}
  \caption{ResaleV1}
  \label{fig:resaleV1}
\end{figure}

The swap works analogously to resale. The major difference is that during a resale a ticket is exchanged for money whereas during a swap a ticket is exchanged for another ticket.

To create a swap offer, the spectator A must specify which token he wishes to swap and for which event he wishes to receive a token in exchange. As for the resale, he can specify an optional spectator B who is the only one who can accept the offer and he must attach the swap approval proof signed by the Approver. The transaction succeeds if the following conditions are met. There is no existing offer to resell this token. There is no existing swap offer for this token. The event whose ticket is wanted by the spectator A exists. The spectator A is the owner of the token. The optional spectator B, if defined, is a registered spectator. The swap approval proof is valid and has been signed by the Approver. It is also possible to cancel a swap offer as long as it has not yet been accepted.

To accept a swap offer, the spectator B must specify which offer he wishes to accept and which token he wishes to give in exchange. The transaction succeeds if the following conditions are met. The token is currently on swap. The spectator B is a registered spectator. The token provided by the spectator B of the offer must be part of the desired event. The spectator B is the optional buyer, if specified. You can find the flow diagram of the swapV1 in the figure \hyperref[fig:swapV1]{\ref{fig:swapV1}}.

\begin{figure}[h!]
  \includegraphics[width=\textwidth]{swapV1.png}
  \caption{SwapV1}
  \label{fig:swapV1}
\end{figure}

This is the initial design. It works but we have the same problem as before. When a spectator creates a resale offer, he must make two transactions. The first transaction authorizes the exchange contract to transfer his ticket. The second transaction creates the resale offer. The spectator who buys the ticket in resale must also make two transactions. The first gives the authorization to the Exchange contract to transfer his TIX and the second transaction accepts the resale offer.

As we explained earlier, this is due to the way the ERC721 and ERC20 standards work. To transfer a property, you must either be the owner or have received the approval of its owner.

In order to fix this limitation, our first approach was to have the TIX contract and ticketing contract whitelist the address of the Exchange smart contract so that it does not need to get user approval. However, this approach is not a good idea as it blurs the line between contracts and their role. Additionally, if the Exchange contract has a security hole, an attacker could potentially steal TIX. The principle of least privilege is not respected with this approach.

Eventually, we found the solution we explained earlier, the externally approved transfer. The idea takes a little time to mature and we explain in the following paragraphs how we came to the idea. We first understood that a transaction is actually just an operation signed by a user that changes the state of the blockchain. However, it is not mandatory for the user himself to be the initiator of this state change as long as the one performing the operation is approved by the user. Therefore, the idea is to use cryptography so that spectators can create off-chain evidence that authorizes the Exchange contract to transfer TIX and tickets on their behalf. As explained previously, we have modified the ERC721 and ERC20 standards so that it accepts this new type of approval. Note that with this approach, there is nothing new to build. Proofs are constructed in the same way as those created by oracles. And the verification mechanism used to verify the proof of the oracles is reused to verify the proof issued by the users. As it is no longer necessary to give approval to transfer the TIX and the tickets, we are halving the number of transactions to be carried out to proceed with a resale.

We take the process even further by only needing a single transaction to complete a resale. With the current design a seller must complete a transaction that lists his resale offer on the Exchange contract. However, there is no need to list the offer directly on the contract. This can be done off-chain to avoid an additional transaction. To do this, the seller creates a resale offer proof. The proof is the exact same proof as the one issued by the Approver but is signed by the seller. This proof is then used by a buyer to purchase the tickets.

If we combine the two approaches, we offer the possibility of reselling a ticket by carrying out a single transaction! It is very useful because it allows us to make atomic resales and thus not to oblige the buyer and the seller to trust each other. Either all the conditions, i.e. the proofs, are met and the resale operation is a success. Either one of the parties refuses to grant an approval and the transaction can only fail. Note that the Exchange smart contract only executes a resale if all the proofs are present and a party in possession of an asset transfer approval proof cannot steal this asset. We do a thorough analysis in the security section.

Here is a high level description of the flow. The seller asks the Approver to create a resale approval proof. Then, the seller creates two proofs. A resale offer proof that authorizes a buyer to purchase his ticket and a ticket transfer approval proof that authorizes the Exchange Contract to transfer the ticket on his behalf. The buyer creates three TIX transfer approval proofs, one per share, that authorize the Exchange contract to transfer the TIX on his behalf. Finally, the buyer creates a resale transaction that contains the six proofs and sends it to the blockchain. The smart contract checks that all authorizations are valid and executes the resale. You can find the flow diagram of the resaleV2 in the figure
\hyperref[fig:resaleV2]{\ref{fig:resaleV2}}.

\begin{figure}[h!]
  \includegraphics[width=\textwidth]{resaleV2.png}
  \caption{ResaleV2}
  \label{fig:resaleV2}
\end{figure}

We use the same approach for the swap in order to obtain an atomic swap. But we also redefine its logic. Indeed, it does not make a lot of sens that the initiator of the swap must specif for which event he wishes to receive a token in exchange. It is too vague and has no real use case. In fact, a swap is a peer-to-peer operation. Two people have something the other wants and they both agree to trade it. 

This is how swap works now. Both parties agree to swap their ticket. One of the two parties, let call them Alice and Bob, asks the oracle to issue a swap approval proof by providing the address of Alice, the address of Bob, the token ID of Alice and the token ID of Bob. Alice and Bob both create two proofs. The first is a swap offer proof. These proofs attest that they both agree to do the swap. The second is a ticket transfer approval proof that allows the exchange to transfer the tokens ownership on their behalf. Finally Alice or Bob makes a swap transaction containing the four proofs and sends it to the blockchain. The smart contract checks that all authorizations are valid and executes the swap. You can find the flow diagram of the swapV2 in the figure \hyperref[fig:swapV2]{ \ref{fig:swapV2}}.

\begin{figure}[h!] 
  \centering
  \includegraphics[scale=0.6]{swapV2.png}
  \caption{SwapV2}
  \label{fig:swapV2}
\end{figure}

To go even further in the process, we could also aggregate the proofs into one in order to reduce the complexity of the verification of the proofs on the smart contract and therefore the transaction execution costs. For instance the approval proofs of the user and the Approver can be aggregated because they are both checked by the Exchange contract. The three externally approved TIX transfer proofs can also be aggregate such that the TIX contract only need to verify a single proof. Of course, the TIX contract must also support batch of transfer. Finally, note that we need a way to aggregate proofs such as homomorphic properties, which is not the case with the proofs we are using.

\section{Graph node}
The graph node runs the graph protocol and allows us to make complex data queries that would be very difficult to do directly on the blockchain.

Let's start by understanding why it is difficult to do complex queries on the blockchain. There are two major limitations. The first is the gas limit. Like transactions, calls cannot have a complexity exceeding a certain limit. If the size of the returned data is too large, the call fails. However, this limitation is easily overcome if the data is simple. All you have to do is split a large query into several sub-queries. For example, if we want to obtain the balance of all the accounts of an ERC20 contract, we can query the first 100 balances in a first request, then the following 100 in a second request and so on. This requires two data structures on the smart contract, a list and a hashmap. The list stores user balance and the hashmap maps a user address to his balance's position in the list. This approach makes it possible to update a user balance in O(1) because the position of his balance is tracked by the hashmap and it is also possible to return all the balances by iterating over the list.

With this approach, it is also possible to easily create simple filters. Let's go back to the previous example and assume that the smart contract stores two additional hashmaps. The first hashmap tracks premium accounts and the second hashmap tracks VIP accounts. If we want to get the balance of all premium and VIP accounts, we can simply iterate over the list of accounts and return only the accounts tracked by one of the two hashmaps.

However, this approach is very limited because it is not possible to create queries as complex and rich as SQL would allow. There is no built-in primitive such as merge, join or filter to manipulate data. Therefore, if one wants to implement a complex query on a smart contract, he needs to implement by himself all these primitives. The code of the function would be very complicated to write and the request would fail as soon as the number of data becomes too large because the maximum gas limit would be reached.

The graph overcomes this limitation by creating an index outside the blockchain. The index is built through event emitted by transactions and can be queried through graphql \footnote{https://graphql.org/} queries.

Here is an overview of how the indexing works. Let's use again the ERC20 contract storing the balance of users as an example. When a user transfers tokens to another user, he first creates a transaction with the following fields: his address, the recipient's address and the amount he wants to transfer. The user sends the transaction to the blockchain which executes it. When the transaction is mined an event containing the three preceding fields is emitted and logged. The graph node listens to this event and updates its index by decrementing the sender's balance and incrementing the receiver's balance. You can find an overview of the flow in the figure \hyperref[fig:graph_node]{\ref{fig:graph_node}}.

\begin{figure}[h!] 
  \centering
  \includegraphics[scale=0.7]{graph_node.png}
  \caption{Graph node}
  \label{fig:graph_node}
\end{figure}

Now that we understand why it's hard to do complex queries or get bulk data, let's take a look at the indexes we use in our system. The graph node maintains three indexes. The first stores the user information, i.e. address, group and balance in TIX. The second stores the event information, i.e. event ID, organizer, name, location, opening date and time, closing date and time, state and number of tickets. The third stores the ticket information, i.e. token ID, ticket ID, event ID, owner and state. To build and maintain these three indexes, the graph node listens to events sent by the four smart contracts. The list of events can be found in the \hyperref[sec:appendix_a]{Appendix A}. Note that thanks to the externally approved transfer, we manage to reduce the amount of data that must be stored in the indexes. With the initial design, we also needed to store the TIX allocation in the ticketing contract, the TIX allocation in the exchange contract, and the ticket status i.e. void, in resale or in swap.

%%%%%%%%%%%%%%%%
\chapter{Security}
%%%%%%%%%%%%%%%%

\section{Security design}
In this section, we explain a few points about the security of the system, and then list the assumptions on which our system is based.

\subsection{Inheritance of Ethereum security}
It should be noted that the business logic is enforced on the blockchain by the four smart contracts. This particular point is very important because it allows the system to inherit the security of the blockchain as long as smart contracts do not have vulnerabilities.

The main benefit of running the business logic on the blockchain is that there is no single point of failure. Indeed, the blockchain is decentralized and therefore managed by many different actors on different infrastructures and in different places. If one of the actors is no longer able to operate correctly, it is not a problem because the other actors continue to operate and provide the service. Furthermore, this properties makes it very difficult to take control and manipulate the blockchain and so our system. Indeed, to be able to control the blockchain, it is necessary to be able to control more than 51\% of the actors which is very difficult to do due to the decentralized and heterogeneous nature of the actors. Of course, zero risk does not exist and it is important to keep in mind that the three main mining pools have together more than 51\% of the hashrate. But it should also be noted that Ethereum has never been compromised since its creation and is certainly one of the most secure decentralized systems at the moment.

Another interesting point is the fact that the smart contracts implementation is public. Indeed, anyone can decompile a smart contract and check what it does. Therefore, anyone can verify that the contracts do what they are supposed to do and that they do not contain malicious code or vulnerabilities. This is a very good thing because an open system bring trust to its users and it forces dapp developers to properly test their code and not rely on security by obfuscation. 

Finally, the history of all user transactions is recorded on the blockchain and is unalterable. As soon as a transaction is mined, it is logged on the blockchain and it is impossible to delete it (unless you control more than 51\% of the network). Therefore, if anyone wants to attack the system, they must do so publicly. Sooner or later, the illegal operations will be noticed by monitoring tools or escalated by a user who notices a fraud, e.g. his tickets have disappeared.

\subsection{Non-custodial design}
We have chosen a non-custodial design, i.e. the keys of the Ethereum wallets are held by the users and not by the system, so that the users are really the owner of their asset and that only they can manipulate them. This approach makes it possible not to have all the keys stored in the same place, which increases the attack surface because there are more potential targets but which also drastically reduces the risk of a successful attack because to have a strong influence on the system, one must be able to compromise a large number of keys.

\subsection{Tamper-proof inputs}
As we mentioned earlier, as much of the business logic as possible is on the blockchain so that it inherits its security. However, we need to use oracles to execute business logic and manipulate data that cannot be on the blockchain. In addition, spectators must create proofs of approval for certain operations. The approach we propose ensures the authenticity and integrity of the data sent on the blockchain because it relies on cryptography. Therefore, as long as the oracles and users are not compromised, all data entering the blockchain is secure, i.e. its integrity and authenticity are guaranteed.

\subsection{Proof-based approval}
In the previous chapter, we explained that many operations used off-chain approval proofs to minimize the number of transactions required to complete it. We now need to show that this approach is secure. We can classify proofs in two types: transaction approval/offer proof and ticket/TIX transfer approval proof. Some operations only require one approval proof, while others require several. In this analysis, we assume that smart contracts do not have security flaws that would allow the verification of a proof to be bypassed. Therefore, for a transaction to succeed, it is necessary that all the proofs are gathered and that they are all valid otherwise the transaction fails. Moreover, since all operations are atomic, the slightest failure of verification implies the complete failure of the operation. Therefore, either the operation is successful as a whole and the changes are written to the blockchain or nothing is changed on the blockchain.

Let's start with the TIX transfer approval proof used when registering a new event and minting new tokens. This proof authorizes the Ticketing contract to transfer TIX on behalf of the organiser. Someone with bad intentions will seek to use this evidence to steal the organizer's TIX. To do this, he will try to modify the proof in order to change the recipient of the funds. In this case, he wants to replace the address of NFTiX with his own. However this is not possible because the new message will not match the message with which the signature was created and therefore the proof verification will fail. The only possible approach is to find a destination address that produces the same message as with the NFTiX address. However, Keccak265 is second pre-image resistant. It is therefore in theory impossible to find an address different from that of NFTiX which will produce the same message. NFTiX may also seek to modify this proof in order to receive more TIX from the organizer. However, this is not possible for the same reasons explained above. Moreover, NFTiX has no reason to do this because it would alienate the organizer and get very bad publicity 

Now let's look at the resale that uses six proofs. There are the resale approval proof, the resale offer proof, ticket transfer approval proof, and the three TIX transfer approval proofs. As explained previously, it is not possible to exploit the TIX transfer approval proof in order to steal the TIX of the buyer. For the same reasons, the same goes for the ticket transfer approval proof. There are three other possible attacks. The first is to try to make an illegal resale that has not been approved by the Approver. To do this, the attacker must successfully forge the signature of the Approver in order to create a fake resale approval proof. This is not possible because the attacker does not know the private key of the Approver. The second attack is to try to resell without the consent of the ticket owner. This is also not possible as the attacker does not have access to the ticket owner's private key and therefore he cannot create a fake resale offer proof and ticket transfer approval proof. The third potential attack is to carry out a partial resale such as the buyer receives the ticket but does not give the TIX in exchange or the seller receives the TIX but does not give the ticket in exchange. This attack cannot work because the operation is atomic. Finally, note that the same analysis is valid for the swap. We do not give it here so as not to unnecessarily lengthen this section.

To conclude our analysis, we will show that it is not possible to reuse old proofs to mount a replay attack and that it is also not possible to use a TIX transfer approval proof created by a third party to steal funds from him.

You have certainly noticed that no mechanism prevents reusing the same proof to mount a replay attack. The reason is that there is actually no need to have one because replay can only fail. Indeed, as the state is no longer the same, the checks performed by the smart contracts fail and so the transaction is reverted. Take for example the case of resale. First, a seller makes a resale offer which is accepted by a buyer. The ticket is transferred to the buyer and the TIXs are transferred to the seller. Now imagine that the seller tries to steal TIX by replaying the resale with the proofs that have been generated beforehand. The resale replay fails because the verification of the ticket owner performed by the smart contract fails. Indeed, the seller is no longer the owner of the ticket. Therefore, replay attacks do not work with our approach. Note that the same is true for swap too.

Now let's look at the second attack, using a third party proof. This attack is not possible because the smart contracts check that the proofs are valid but they also check that the transaction corresponds to the proof. Let's illustrate this with an example. Assume that a resale has taken place between a buyer and a seller, let's call them Alice and Bob. Now imagine that Alice resells a second ticket at the same price to another buyer, let's call her Clara. Clara tries to use the TIX transfer approval proof from the old resale in order to make a resale transaction while keeping her TIXs. This attack is not possible for two reasons. First, the verification of the proof fails because it was not signed by Clara but by Bob. Second, the Exchange contract verifies that the funds are indeed transferred from the buyer to the seller, in this case from Clara to Alice, which is not the case. Therefore, it is not possible to mount this kind of attack.

The key point to understand is that once a transaction has been made, the state of the system no longer matches the proofs. Therefore, although proofs do not contain a mechanism to prevent their reuse, it is not possible to use them for dishonest purposes.

To conclude, we must specify that this type of approval should only be given to a smart contract. If someone creates a TIX transfer approval proof for an external address, the owner can use this proof several times without anything preventing him from doing so. He can therefore completely steal the TIX of the person who generated the proof. Therefore, this proof should be used with care and only to authorize a smart contract to transfer an asset on our behalf.

\section{Threat model}
The design we propose is based on several assumptions. The first assumption is that the organizers and the operators of NFTiX are not malicious. Indeed, organizers have the ability to delete tickets arbitrarily and system operators can revoke a user at will. Nothing prevents them from doing this kind of actions. However, we assume that this assumption is reasonable as it is unlikely that they will commit such actions. Indeed, they have more to lose than to gain. Their reputation and the trust in the system would be damaged and this would have a direct impact on their income.

The second assumption is that the blockchain is considered completely secure and therefore trustworthy. Thanks to the decentralized nature of the blockchain, this assumption is reasonable. Indeed, it is difficult to attack the blockchain. To manipulate it, one must be able to take control of more than 51\% of the network or be able to break the cryptographic primitives on which it is based. It is highly unlikely that this will happen.

The third assumption is that the oracles private key is not accessible by anyone Therefore only oracles can generate valid proofs and update the price of the TIX. This assumption requires that the oracles and the infrastructure on which the oracles run are secure. This requires intensive testing and monitoring of this part of the system which is crucial for having a regulated system. We believe that this assumption is reasonable because the web as we know it is based on this same assumption.

Finally, we assume that the code of oracles and smart contracts does not contain vulnerabilities that could be exploited to steal TIXs or tickets. It is sadly not possible to ensure that a code does not contain any flaws. However, we believe that due to the relatively low complexity of the system, it is possible to test the code sufficiently in order to have a high level of confidence in its security.

The design based on these four assumptions ensures that the business logic is applied as it should be and that users cannot deviate from the protocol. If they try, their actions will be denied. Let's take for example a malicious user who seeks to make a resale that does not respect the resale rules. To perform this operation, he must obtain a resale approval proof from the oracle. As the resale is illegal the oracle will refuse to provide the proof. The user cannot forge a false proof because he does not have access to the private key of the oracle and because we assume that the cryptography is robust. The user cannot attack the smart contract because we assume that it has been sufficiently tested so that it does not contain any vulnerability. The user cannot attack the blockchain either because we assume that it cannot be manipulated.

Finally, it should be noted that if a malicious user managed to find a flaw and exploit it, these actions would be visible because the blockchain records all the operations that are carried out. For example, suppose someone has noticed a vulnerability in the code of a smart contract that allows him to transfer any ticket, even if it does not belong to him. This flaw allows him to acquire all the tickets he wants. However, if he uses this flaw and transfer a ticket to himself he would automatically unmask himself. In addition, it is possible to undo his actions. Indeed, the organiser can delete the stolen ticket and recreate a new one for the user who has been stolen. Of course, it is also necessary to fix the flaw otherwise the malicious user could start again.

%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%
The implementation of the system is on Github \footnote{https://github.com/SirBouboute/marketplace}. It should be noted that the implementation is at the POC stage. The system is simulated through scripts and tests. However, there is everything needed to make it a production system with dedicated servers, APIs, etc.

The programming languages used are Solidity \footnote{https://docs.soliditylang.org/en/v0.8.12/} for smart contracts and Typescript for scripts and tests. 

We used Hardhat as development and test environment with the following plugins: hardhat-waffle, ethereum-waffle, chai, hardhat-ethers ethers, hardhat-etherscan, dotenv, eslint, hardhat-gas-reporter, prettier, solhint, solidity -coverage, mocha, ts-node, typechain and typescript. 

About the smart contract, we use the implementation of OpenZeppelin for the ERC20 standard, the ERC721 standard and the ECDSA signature verification.

%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
%%%%%%%%%%%%%%%%%%%%
\section{Proof vs fact registry contract}
We want to provide a quick comparison of our proof-based approval approach with another approach that more or less addresses the same problem. This approach is to use a smart contract to store facts \footnote{https://docs.starkware.co/starkex-v4/starkex-deep-dive/smart-contracts-1/fact-registry}. This approach is more generic than ours because a fact is not limited to external approval. It can be anything like for example the price of a token against another one at a given time. This is very practical for building for example an AMM. Another interesting point is that a fact can be signed by several parties. This could be very practical for NFTiX because in the context of a resale, we could for example have a single fact signed by the seller, the buyer and the Approver instead of having six proofs. This approach also makes it possible to clearly separate the business logic and the external approval logic because the fact verification code is only on the fact registry contract and not on all the smart contracts as in our case.

However, we decided not to use this approach for several reasons. The first is that our approach is less gas-consuming because we only check the proofs but do not write anything to the blockchain. It is sometimes useful to have persistence but in our case it is not necessary. The second reason is that a fact registry contract might be a single point of failure. If there is a vulnerability, our external approval system can be completely compromised while by spreading the work across several different contracts we reduce the risk in the event of a vulnerability in one contract. The idea is to follow the least privilege principal. Finally, the main reason for our choice is that with our approach we can have transactions that are atomic as a whole and do not require to do preparation transactions such as approval or fact registration. We believe this is a real advantage because by reducing the number of steps needed to complete an action, it greatly reduces the attack surface and the complexity of the system while ensuring an equivalent level of security.

\section{Performance}

\subsection{Experimental setup}
The tests were performed on a Dell latitude 5501 laptop with an i7-9850H processor and 16GB of RAM in the WSL2 environment.

\subsection{Throughput and latency}
We cannot give an exact measurement of the throughput and latency on the blockchain because it would cost a lot of gas, even on a testnet. Therefore, we give estimates based on statistics.

Ethereum operates at a rate of around 15 TPS and has a block confirmation time of around 15 seconds. This is clearly insufficient to support NFTiX. Indeed, even by paying the maximum gas fee so that the transactions are integrated in the next block, the transaction confirmation time is a little too long. Users don't want to wait 15 seconds for their transaction to complete. Moreover, there is another problem. We can reasonably estimate that NFTiX must support at max around 10,000 transactions daily. It represents the minting of 3'000'000 new tokens with a batch of size 300 or 10'000 resales. Ethereum has a daily volume of around 1,300,000 transactions. Which means that NFTiX alone would use about 0.8\% of the network which is way to much. Clearly, Ethereum cannot support NFTiX at this time.

Polygon with around 100 TPS and a block confirmation time of around 2 seconds is a better candidate. A potential transaction confirmation time of around 2 seconds is perfectly acceptable. Moreover, using the same assumptions as before, we obtain a use of around 0.1\% of the network. Solana is another interesting candidate. It has a TPS of around 2400 and a block confirmation time of around 0.8 seconds. NFTiX would use about 0.004\% of the network which is perfectly fine.

So, the estimation show that it could be possible at the moment to deploy NFTiX on Polygon or on Solana. However, as more and more projects are deployed on these networks, there is an high chance that in the future they will suffer from the same congestion as Ethereum does. However, rollups seems very promising and would certainly solve this scalability problem.

\subsection{Max batch size}
In the table \hyperref[table:max_batch_size]{\ref{table:max_batch_size}} you can find the maximum batch size supported by the Ticketing contract on mint, burn and update operations on tickets. These are the maximum size of a batch before the operation is reverted because the gas limit is reached. Note that we could use compression tricks and we could also optimize the contract code in order to increase theses maximum batch sizes but we consider these numbers sufficiently good for a POC.

\begin{table}[h!]
\begin{center}
\begin{tabular}{ |c|c|c| }
 \hline
 Max mint batch size & Max burn batch size & Max update batch size \\
 \hline
 300 \pm 10 & 970 \pm 10 & 410 \pm 10 \\
 \hline
\end{tabular}
\caption{Maximum batch size per operation}
\label{table:max_batch_size}
\end{center}
\end{table}

\subsection{Proof generation}
In the table \hyperref[table:signatures]{\ref{table:signatures}} you can see the time it takes to compute the hash, the signature and the hash + the signature, i.e. a proof, of request batch of different sizes. The time is in seconds and in parenthesis is the average time of a single operation.

\begin{table}[h!]
\begin{center}
\begin{NiceTabular}{ |c||c|c|c| }
 \hline
 Batch size & Hashing (s) & Signing (s) & Proof (s) \\
 \hline \hline
 1'000   & 0.2164 (0.0002) & 0.3566 (0.0004) & 0.5779 (0.0006) \\
 10'000 & 1.563 (0.0002) & 2.968 (0.0003) & 4.956 (0.0005) \\
 100'000 & 14.59 (0.0001) & 26.18 (0.0003) & 50.37 (0.0005) \\
 1'000'000 & 147.1 (0.0001) & 256.7 (0.0003) & 509.9 (0.0005) \\
 \hline
\end{NiceTabular}
\caption{Proof batch generation time}
\label{table:signatures}
\end{center}
\end{table}

The result highlights that the creation of the proofs is not time nor resource consuming at all. Note that the verification of the rules and the network latency are not taken into account in the measurement therefore we should expect that the operation take slightly more time to execute. However also not that these tests have been made on a single core of a laptop which is not the hardware that would be use in production. So we can conclude that the oracles can easily sustain more than 1500 proof generations per second which is perfectly enough for our purpose.

\section{Costs}
The measure has been done the 21.02.2022 with the compiler version 0.8.12 and with the optimizer enabled and set to 200.

\subsection{Contract deployment}
The table \ref{table:contracts_deployment_price} gives the average prices for deploying smart contracts. Without surprise it is very expensive to deploy them on Ethereum. However it is still very cheap to do it on Polygon and it would be perfectly bearable for a company like Secutix SA.

\begin{table}[h!]
\begin{center}
\begin{NiceTabular}{ |c||c|c|c| }
 \hline
 Contract & Avg gas (Gwei) & Avg cost in Ethereum (CHF) & Avg cost in Ethereum (CHF) \\
 \hline \hline
 Identity & 763'699 & 126.70 & 0.03 \\
 TIX & 1'447'729 & 240.18 & 0.06 \\
 Ticketing & 3'873'386 & 642.59 & 0.16 \\
 ExchangeV1 & 2'179'969 & 361.66 & 0.09 \\
 ExchangeV2 & 1'255'857 & 208.35 & 0.05 \\
 \hline
\end{NiceTabular}
\caption{Contracts deployment price on Ethereum and Polygon}
\label{table:contracts_deployment_price}
\end{center}
\end{table}

\subsection{Transaction cost}
The table \ref{table:identity_contract_transaction_cost}, \ref{table:tix_contract_transaction_cost}, \ref{table:ticketing_contract_transcation_cost}, \ref{table:exchangeV1_contract_transaction_cost}, \ref{table:exchangeV2_contract_transaction_cost} give the average prices of transactions. As for the deployment of contracts, it is not conceivable to operate NFTiX on Ethereum. Paying around 30 CHF to mint or to resell a token is way too expensive. On the other hand, Polygon is very interesting. It only costs around 0.0004 CHF to mint a token. You can find more data about costs on Ethereum and Polygon in appendix \ref{sec:appendix_b}. There is also cost measurement for the Avalanche blockchain and the Binance smart chain.

\begin{table}[h!]
\begin{center}
\begin{NiceTabular}{ |c||c|c|c| }
 \hline
 Transaction & Avg gas (Gwei) & Avg cost in Ethereum (CHF) & Avg cost in Ethereum (CHF) \\
 \hline \hline
 Register & 54'663 & 9.07 & < 0.01 \\
 Unregister & 27'781 & 4.61 & < 0.01 \\
 Revoke & 30'582 & 5.07 & < 0.01 \\
 \hline
\end{NiceTabular}
\caption{Identity contract transaction price on Ethereum and Polygon}
\label{table:identity_contract_transaction_cost}
\end{center}
\end{table}

\begin{table}[h!]
\begin{center}
\begin{NiceTabular}{ |c||c|c|c| }
 \hline
 Transaction & Avg gas (Gwei) & Avg cost in Ethereum (CHF) & Avg cost in Ethereum (CHF) \\
 \hline \hline
 Mint & 70'470 & 11.69 & < 0.01 \\
 Burn & 29'089 & 4.83 & < 0.01 \\
 Buy & 65'884 & 10.93 & < 0.01 \\
 Sell & 35'368 & 5.87 & < 0.01 \\
 UpdateRates & 31'841 & 5.28 & < 0.01 \\
 \hline
\end{NiceTabular}
\caption{TIX contract transaction price on Ethereum and Polygon}
\label{table:tix_contract_transaction_cost}
\end{center}
\end{table}

\begin{table}[h!]
\begin{center}
\begin{NiceTabular}{ |c||c|c|c| }
 \hline
 Transaction & Avg gas (Gwei) & Avg cost in Ethereum (CHF) & Avg cost in Ethereum (CHF) \\
 \hline \hline
 RegisterEvent & 213'381 & 35.40 & 0.01 \\
 UpdateEventState & 31'032 & 5.15 & < 0.01 \\
 Mint & 173'709 & 28.82 & 0.01 \\
 MintBatch & 28'984'724 & 4808.55 & 1.18 \\
 Burn & 29'089 & 4.83 & < 0.01 \\
 BurnBatch & 7'243'121 & 1201.63 & 0.30 \\
 UpdateTokenState & 35'445 & 5.88 & < 0.01 \\
 UpdateTokenStateBatch & 3'812'565 & 632.50 & 0.16 \\
 TransferFrom & 72'141 & 11.97 & < 0.01 \\
 \hline
\end{NiceTabular}
\captionsetup{justification=centering}
\caption{Ticketing contract transaction cost. The batch size used for the measurement are the maximum batch size given above}
\label{table:ticketing_contract_transcation_cost}
\end{center}
\end{table}

\begin{table}[h!]
\begin{center}
\begin{NiceTabular}{ |c||c|c|c| }
 \hline
 Transaction & Avg gas (Gwei) & Avg cost in Ethereum (CHF) & Avg cost in Ethereum (CHF) \\
 \hline \hline
 CreateResale & 83'772 & 13.90 & < 0.01 \\
 AcceptResale & 157'745 & 26.17 & 0.01 \\
 CancelResale & 30'765 & 5.10 & < 0.01 \\
 CreateSwap & 73'467 & 12.19 & < 0.01 \\
 AcceptSwap & 87'081 & 14.45 & < 0.01 \\
 CancelSwap & 30'826 & 5.11 & < 0.01 \\
 \hline
\end{NiceTabular}
\caption{ExchangeV1 contract transaction price on Ethereum and Polygon}
\label{table:exchangeV1_contract_transaction_cost}
\end{center}
\end{table}

\begin{table}[h!]
\begin{center}
\begin{NiceTabular}{ |c||c|c|c| }
 \hline
 Transaction & Avg gas (Gwei) & Avg cost in Ethereum (CHF) & Avg cost in Ethereum (CHF) \\
 \hline \hline
 Resell & 186'680 & 30.97 & 0.01 \\
 Swap & 111'984 & 18.58 & < 0.01 \\
 \hline
\end{NiceTabular}
\caption{ExchangeV2 contract transaction price on Ethereum and Polygon}
\label{table:exchangeV2_contract_transaction_cost}
\end{center}
\end{table}

\subsection{Proof verification cost}
Verification of proof on the blockchain costs between 6500 and 10000 gas. This corresponds to a cost increase between 7 and 15\% compared to the same transactions executed without verification of proof. Although these numbers seem large, we remind you that thanks to proofs, we can execute a good part of the business logic off-chain and therefore drastically reduce the costs of transactions.

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Limitation and future work}
%%%%%%%%%%%%%%%%%%%%%%

\section{Off-chain ticket state}
When designing the system, we tried to put on-chain as much as possible of the business logic. The state of a ticket is one of the elements that is managed on-chain. However, upon reflection we think this is a mistake. The INVALID ticket state is not necessary because it is possible to delete tickets that are no longer useful. In addition, it costs less to delete a ticket than to update its state thanks to the gas refund when a memory element is freed. The SCANNED state is useful but only locally during the event for access control. Therefore, it is not necessary to store it on the blockchain. In addition, updating each scanned ticket can potentially create heavy congestion on the blockchain if several thousand state updates are made at the same time. This can be problematic as tickets could be scanned multiple times before their state is updated. Therefore, this information should be stored off-chain and updated in batch if needed on the blockchain. 

\section{Proof of ownership and scanner oracle}
An aspect that has not been addressed in this thesis is the management of the QR code that is scanned at the entrance of the event. TIXnGO uses encrypted QR codes which are revealed before the start of the event. The activation of the QR code can be done using bluetooth beacons. When the phone receives the signal from the beacon, it reveals the QR code. This can also be done with a time based activation. In this case, the QR code is activated a few hours before the start of the event.

The problem with this approach is that the QR code and the decryption key must be permanently stored on the user's phone because it is possible that the user is not able to access the internet once outside the entrance. Often, the quality of the mobile network is degraded because there are many people. Although it is possible to store the private key in the phone's secure enclave and extensively test the application code to ensure that it is very difficult to extract the QR code and use it at malicious purposes, this approach is not optimal.

Another approach is to generate a QR code that depends on the ticket owner, i.e. if two people had the same ticket, they would see a different QR code. With this approach, it is not necessary to encrypt the QR code. This approach is relatively easy to set up and has already been tested by AlphaWallet. The approach consists in generating a proof of ownership attesting that the person holds the ticket. To do this, the person proves that he is the owner of the address holding the ticket. The proof is then used to construct the QR code. You can find more info here\footnote{https://medium.com/opensea/cryptotickets-the-first-blockchain-based-tickets-are-live-on-opensea-5a29d0223c3d}.

\section{External payment channel and proof}
At the moment crypto remains a niche market and most people still prefer to pay with fiat currencies. There are two ways to solve this problem. The first is to use a fiat to crypto converter such as Ramp \footnote{https://ramp.network/}. In the context of a resale, a user can use Ramp to purchase with his credit card the number of TIX required to satisfy a resale. Once the payment is made, the TIXs are automatically transferred to the seller without the buyer having to do anything.

However, this approach implies that the seller receives TIXs when he may wish to receive the amount in fiat currency. It is possible to convert TIX into fiat currency but this involves a conversion and therefore additional costs. To fix this limitation NFTiX can also support an external payment system such as Stripe \footnote{https://stripe.com/fr-ch}. This approach requires a slight change in how resale works. The buyer's three TIX transfer approval proofs are replaced by a single proof issued by an oracle that handles external payments. During a resale, the oracle creates a payment request. Once the buyer has made the payment, the oracle generates a proof that the payment has been executed and returns it to the buyer who uses it to make the resale.

\section{Decentralized oracles}
As we mentioned previously, oracles are centralized. This is not a good thing because it creates a single point of failure, it opens the door to censorship and it goes against the philosophy of decentralization. To overcome these problems, we could use a decentralized oracle such as Chainlink.

\section{payment splitter with single proof}
With out approach, the buyer of a ticket needs to create three TIX transfer approval proof and the Exchange smart contract needs to call three time the transferFrom function of the TIX contract in order to transfer the three shares. To avoid this we can use a payment splitter and a single proof. The splitter checks that the proof is valid and then transfer the shares in a single function call and so save some gas. 

\section{TIX token features}
For the moment, the TIX token has very little use and it could perfectly be replaced by ETH. Here are some ideas that might make it more useful.

The TIX could be used as a governance token so that users can vote for new features in the application. For example, it would be possible to make a vote to determine if the spectators would like to have the possibility of claiming a souvenir ticket of an event in the form of NFT. The governance could also let the organizers vote for the next features they would like the development team to implement first.

It would also be possible to create a reward pool that can be shared regularly between the most assiduous users of the application or to people who discover security flaws in the system. The pool could be filled by taking a small commission on each resale of tickets.

Another cool feature would be that the exchange redeems tickets for TIXs. Sometimes someone can't attend an event for some reason and fails to sell their ticket. It would be great if that person could return their ticket and get some TIX in exchange because they could then use those TIX to buy another ticket in the future. This could create a kind of virtuous circle.

Finally, the token should be listed in a decentralized exchange such as Uniswap or Curve instead of using the buy function which locks ETH and mint TIX in exchange. This approach is not scalable at all because if the TIX takes a lot of value compared to ETH, the amount of ETH in the smart contract will no longer be enough to reimburse people who sell their TIX.

\section{Performance test on zkSync and StarkNet}
The zk rollups, which in our opinion are the future of blockchain scalability, are becoming increasingly popular. It would be interesting to see how well the system would perform and what changes would need to be made to the system in order to make it work on these layer 2.

\section{Mixing custodial and non-custodial design}
As we explained previously a non-cusdodial design is necessary to ensure that the users are the owners of their assets. However, it is also risky because user are often not really aware of the risks they take. In the other hand, a custodial design is in general safer because very high standards of security can be used to protect private keys.

But why not mix the two worlds in order to have a high level of security while allowing the users to own their assets? This could be possible with an MPC. The idea is that transaction signatures are done by both the user and the system. With this approach the user still has the control of his asset because if he does not provide his share, the transaction cannot be made. And an high-level of security can be achieved because the system use the highest standard of security to protect its share.

In addition, this approach could perhaps make it possible to build a regulation system similar to the one we propose but which is also much simpler because it does not require on-chain proof verification. Indeed, in addition to the user and the system share, the regulator could bring a share to construct the signature of the transaction in order to give its approval. If the regulator does not give its share the transaction will be refused. However, there needs to be a mechanism to ensure that the signature includes the shares of all parties involved. Adapting Shamir's Secret Sharing could be a good starting point to build such a mechanism.

%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%

\textit{In the conclusion you repeat the main result and finalize the discussion of
your project. Mention the core results and why as well as how your system
advances the status quo.} \\

NFTiX is a ticket engine that aims to be the foundation for the new TIXnGO ticket distribution system. It includes a user management system, an event and ticket management system and a ticket exchange management system that is secure, decentralized, regulated and non-custodial. To our knowledge, there is no such system yet at the time of writing this thesis.

Our core contribution is our regulation strategy through external proofs that allow atomic operations to be performed and our completely non-custodial design that allows users to be the sole owners of their asset.

Finally, our security analysis shows that our system fulfills well its role in the fight against the black market and fraud and our evaluation shows that it is possible to put NFTiX into production because the costs would not be too high and the performance sufficient.


\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\nocite{*}
\printbibliography

\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{List of events}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:appendix_a}

TODO: add ExchangeV2 events

The structure of an event is the following: 
\begin{verbatim}
EventName(typeOfFirstElt nameOfFirstElt, typeOfSecondElt nameOfSecondElt, ...)
\end{verbatim}



\paragraph{Identity}
\begin{verbatim}
Registation(address user, bytes32 class, bytes32 hash, bytes signature);
Unregistration(address user);
Revocation(address user);
\end{verbatim}

\paragraph{TIX}
\begin{verbatim}
Purchase(address user, uint256 amount);
Sale(address user, uint256 amount);
Transfer(address from, address to, uint256 value);
Approval(address owner, address spender, uint256 value);
\end{verbatim}

\paragraph{Ticketing}
\begin{verbatim}
EventRegistration(uint256 eventId, address owner);
EventUpdate(uint256 eventId, bytes32 state);
Minting(uint256 tokenId, uint256 ticketId, address owner);
Burning(uint256 tokenId, uint256 ticketId);
TokenUpdate(uint256 tokenId, bytes32 state);
Transfer(address from, address to, uint256 tokenId);
Approval(address owner, address approved, uint256 tokenId);
\end{verbatim}

\paragraph{Exchange}
\begin{verbatim}
CreateResale(uint256 tokenId, uint256 price, address optionalBuyer);
CancelResale(uint256 tokenId);
AcceptResale(address seller, address buyer, uint256 tokenId, uint256 price);
CreateSwap(uint256 tokenId, uint256 eventIdOfWantedToken, address optionalParticipant);
CancelSwap(uint256 tokenId);
AcceptSwap(address creator, address acceptor, uint256 creatorTokenId, 
           uint256 acceptorTokenId);
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Extended cost}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:appendix_b}

\begin{center}
\begin{figure}[h!] 
  \includegraphics[width=\textwidth]{transactions_price_ethereum_21_02_2022.PNG}
  \caption{Transaction price on Ethereum the 21.02.2022}
  \label{fig:transactions_price_ethereum_21_02_2022}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[h!] 
  \includegraphics[width=\textwidth]{transactions_price_polygon_21_02_2022.PNG}
  \caption{Transaction price on Ethereum the 21.02.2022}
  \label{fig:transactions_price_polygon_21_02_2022}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[h!] 
  \includegraphics[width=\textwidth]{transactions_price_avalanche_21_02_2022.PNG}
  \caption{Transaction price on Ethereum the 21.02.2022}
  \label{fig:transactions_price_avalanche_21_02_2022}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[h!] 
  \includegraphics[width=\textwidth]{transactions_price_binance_21_02_2022.PNG}
  \caption{Transaction price on Ethereum the 21.02.2022}
  \label{fig:transactions_price_binance_21_02_2022}
\end{figure}
\end{center}

\end{document}